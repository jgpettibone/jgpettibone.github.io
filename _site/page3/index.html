<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>Jeanette Pettibone &#8211; Hacking Away</title>
<meta name="description" content="Describe this nonsense.">
<meta name="keywords" content="JavaScript, Software Engineering, Full Stack, blog">

<!-- Twitter Cards -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="/images/corememory3.jpg">

<meta name="twitter:title" content="Jeanette Pettibone">
<meta name="twitter:description" content="Describe this nonsense.">
<meta name="twitter:creator" content="@jgpettibone">

<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Jeanette Pettibone">
<meta property="og:description" content="Describe this nonsense.">
<meta property="og:url" content="/page3/index.html">
<meta property="og:site_name" content="Hacking Away">





<link rel="canonical" href="/page3/">
<link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Hacking Away Feed">


<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.min.css">
<!-- Webfonts -->
<link href="http://fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css">

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="/images/apple-touch-icon-precomposed.png">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="/images/apple-touch-icon-72x72-precomposed.png">
<!-- 114x114 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="/images/apple-touch-icon-114x114-precomposed.png">
<!-- 144x144 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/images/apple-touch-icon-144x144-precomposed.png">




<style type="text/css">body {background-image:url(/images/witewall_3.png);}</style>


</head>

<body id="post-index" class="feature">

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
<nav id="dl-menu" class="dl-menuwrapper" role="navigation">
	<button class="dl-trigger">Open Menu</button>
	<ul class="dl-menu">
		<li><a href="">Home</a></li>
		<li>
			<a href="#">About</a>
			<ul class="dl-submenu">
				<li>
					<img src="/images/mylinkedinphoto.jpg" alt="Jeanette Pettibone photo" class="author-photo">
					<h4>Jeanette Pettibone</h4>
					<p>Full Stack Software Engineer. Linguist. Computer and Natural Language Processor.</p>
				</li>
				<li><a href="/about/">Learn More</a></li>
				
				
				
				<li>
					<a href="http://github.com/jgpettibone"><i class="icon-github"></i> GitHub</a>
				</li>
				<li>
					<a href="http://linkedin.com/in/jeanettepettibone"><i class="icon-linkedin"></i> LinkedIn</a>
				</li>
				<li>
					<a href="http://twitter.com/jgpettibone"><i class="icon-twitter"></i> Twitter</a>
				</li>
				
				
				
				
			</ul><!-- /.dl-submenu -->
		</li>
		<li>
			<a href="#">Posts</a>
			<ul class="dl-submenu">
				<li><a href="/posts/">All Posts</a></li>
				<li><a href="/tags/">All Tags</a></li>
			</ul>
		</li>
		
	</ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->


<div class="entry-header">
  
  
    <div class="entry-image">
      <img src="/images/corememory3.jpg" alt="Jeanette Pettibone">
    </div><!-- /.entry-image -->
  
  <div class="header-title">
    <div class="header-title-wrap">
      <h1>Hacking Away</h1>
      <h2>Jeanette Pettibone</h2>
    </div><!-- /.header-title-wrap -->
  </div><!-- /.header-title -->
</div><!-- /.entry-header -->

<div id="main" role="main">
  
<article class="hentry">
  <header>
    <div class="entry-meta"><span class="entry-date date published updated"><time datetime="2014-02-04T00:00:00-08:00"><a href="/coin-sums/">February 04, 2014</a></time></span><span class="author vcard"><span class="fn"><a href="/about/" title="About Jeanette Pettibone">Jeanette Pettibone</a></span></span></div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="/coin-sums/" rel="bookmark" title="Coin Sums" itemprop="url">Coin Sums</a></h1>
    
  </header>
  <div class="entry-content">
    <!-- <h2 id="the-problem">The Problem</h2>
<p>How many possible ways can you make change for 2£ given the following English coins:
1p, 2p, 5p, 10p, 20p, 50p, 1£ (100p), 2£ (200p)?</p>

<p>One example output would be:
5 x 1p, 5 x 2p, 1 x 5p, 1 x 10p, 1 x 20p, 1 x 50p, 1 x 1£</p>

<h2 id="understanding-the-problem">Understanding the Problem</h2>
<p>This problem deals with the possible permutations of coins that equal 2£.  However, it is not a pure combinatorics problem like <a href="http://jgpettibone.github.io/rock-paper-scissors/">Rock Paper Scissors</a> because we do not want duplicates (1 x 1p,1 x 2p is the same as 1 x 2p,1 x 1p and therefore we should only count one of these as a possible combinations.)    </p>

<p>Let’s start off by looking at a smaller version of this problem.  Imagine that we have only 3 different types of coins - 1p, 5p, and 10p - and we’re trying to make ‘piles’ of coins that sum up to 20p.  What are the possible coin combinations that we can make?</p>

<p>Number of coins of each type used:</p>

<table rules="groups">
  <thead>
    <tr>
      <th style="text-align: left">10p -</th>
      <th style="text-align: center">- 5p  -</th>
      <th style="text-align: right">- 1p</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: right">20</td>
    </tr>
    <tr>
      <td style="text-align: left">0</td>
      <td style="text-align: center">1</td>
      <td style="text-align: right">15</td>
    </tr>
    <tr>
      <td style="text-align: left">0</td>
      <td style="text-align: center">2</td>
      <td style="text-align: right">10</td>
    </tr>
    <tr>
      <td style="text-align: left">0</td>
      <td style="text-align: center">3</td>
      <td style="text-align: right">5</td>
    </tr>
    <tr>
      <td style="text-align: left">0</td>
      <td style="text-align: center">4</td>
      <td style="text-align: right">0</td>
    </tr>
    <tr>
      <td style="text-align: left">1</td>
      <td style="text-align: center">0</td>
      <td style="text-align: right">10</td>
    </tr>
    <tr>
      <td style="text-align: left">1</td>
      <td style="text-align: center">1</td>
      <td style="text-align: right">5</td>
    </tr>
    <tr>
      <td style="text-align: left">1</td>
      <td style="text-align: center">2</td>
      <td style="text-align: right">0</td>
    </tr>
    <tr>
      <td style="text-align: left">2</td>
      <td style="text-align: center">0</td>
      <td style="text-align: right">0</td>
    </tr>
  </tbody>
</table>

<p>There is a pattern here.  Looking at the first row of this table, we might think of this problem as starting by looking the largest-valued coin (10p) with 20p value needed to reach the total and adding none of this type of coin, and then looking at the next-largest-valued coin (5p) with still 20p value needed and adding none of this type of coin, and then finally getting to the 1p coin and iterating through to add 20 x 1p coins to reach the total of 20p.  Now look at the second row of the table.  We look at the largest-valued coin (10p) with 20p value needed to reach the total and adding none of this type of coin, and then looking at the next-largest-valued coin (5p) with still 20p value needed and add one of this type of coin, and then finally getting to the 1p coin and iterating through to add 15 x 1p coins to reach the total of 20p.  In Javascript, this pattern looks like it could be represented by a series of nested for loops.    </p>

<h2 id="the-code">The Code</h2>
<p>Let’s translate this problem into Javascript and write a function called <code>makeChange</code>.</p>

<h3 id="input-and-output">Input and Output</h3>
<p>The argument of the function is a variable called <code>total</code>.  Since our goal is for the coins to sum up to 2£ (or 200p), we’ll call <code>makeChange</code> with 200.</p>

<p>The return value is the number of possible ways to make change for the total.  This will be represented as a counter named <code>count</code> initialized to 0.</p>

<p>This gives us the basic structure below:</p>

<div class="highlight"><pre><code class="javascript"><span class="kd">var</span> <span class="nx">makeChange</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">total</span><span class="p">)</span> <span class="p">{</span>

  <span class="kd">var</span> <span class="nx">coins</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">50</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">200</span><span class="p">];</span>
  <span class="kd">var</span> <span class="nx">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">return</span> <span class="nx">count</span><span class="p">;</span>
<span class="p">};</span>

<span class="nx">makeChange</span><span class="p">(</span><span class="mi">200</span><span class="p">);</span>
</code></pre></div>

<h3 id="to-iterate-or-to-recurse">To Iterate or to Recurse?</h3>
<p>An iterative approach requires that we hard-code each of the type of coins in their own for loop.  An iterative solution might look something like the following:</p>

<div class="highlight"><pre><code class="javascript"><span class="kd">var</span> <span class="nx">makeChange</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">total</span><span class="p">)</span> <span class="p">{</span>

  <span class="kd">var</span> <span class="nx">coins</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">50</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">200</span><span class="p">];</span>
  <span class="kd">var</span> <span class="nx">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="nx">total</span><span class="p">;</span> <span class="nx">a</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">a</span> <span class="o">-=</span> <span class="nx">coins</span><span class="p">[</span><span class="nx">coins</span><span class="p">.</span><span class="nx">length</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="nx">a</span><span class="p">;</span> <span class="nx">b</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">b</span> <span class="o">-=</span> <span class="nx">coins</span><span class="p">[</span><span class="nx">coins</span><span class="p">.</span><span class="nx">length</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">c</span> <span class="o">=</span> <span class="nx">b</span><span class="p">;</span> <span class="nx">c</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">c</span> <span class="o">-=</span> <span class="nx">coins</span><span class="p">[</span><span class="nx">coins</span><span class="p">.</span><span class="nx">length</span><span class="o">-</span><span class="mi">3</span><span class="p">])</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">d</span> <span class="o">=</span> <span class="nx">c</span><span class="p">;</span> <span class="nx">d</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">d</span> <span class="o">-=</span> <span class="nx">coins</span><span class="p">[</span><span class="nx">coins</span><span class="p">.</span><span class="nx">length</span><span class="o">-</span><span class="mi">4</span><span class="p">])</span> <span class="p">{</span>
          <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">e</span> <span class="o">=</span> <span class="nx">d</span><span class="p">;</span> <span class="nx">e</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">e</span> <span class="o">-=</span> <span class="nx">coins</span><span class="p">[</span><span class="nx">coins</span><span class="p">.</span><span class="nx">length</span><span class="o">-</span><span class="mi">5</span><span class="p">])</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="nx">e</span><span class="p">;</span> <span class="nx">f</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">f</span> <span class="o">-=</span> <span class="nx">coins</span><span class="p">[</span><span class="nx">coins</span><span class="p">.</span><span class="nx">length</span><span class="o">-</span><span class="mi">6</span><span class="p">])</span> <span class="p">{</span>
              <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">g</span> <span class="o">=</span> <span class="nx">f</span><span class="p">;</span> <span class="nx">g</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">g</span> <span class="o">-=</span> <span class="nx">coins</span><span class="p">[</span><span class="nx">coins</span><span class="p">.</span><span class="nx">length</span><span class="o">-</span><span class="mi">7</span><span class="p">])</span> <span class="p">{</span>
                <span class="nx">count</span><span class="o">++</span><span class="p">;</span>
              <span class="p">}</span>
            <span class="p">}</span>
          <span class="p">}</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">count</span><span class="p">;</span>
<span class="p">};</span>

<span class="nx">makeChange</span><span class="p">(</span><span class="mi">200</span><span class="p">);</span>
</code></pre></div>

<p>Note that the <code>coins[coins.length-1]</code> notation looks a little strange, but the idea is to show the similarities between this iterative solution and the solution coming in the section below.</p>

<p>The iterative function works but it’s not very elegant.  In fact, the coin sums problem can easily be divided into a series of similar subproblems - get all the combinations of coins with just 1p coins, all the combinations with 1p and 2p coins, all the combinations with 1p, 2p, and 5p coins, etc - and a problem like this is perfect for a recursive function.</p>

<h2 id="the-recursive-function">The Recursive Function</h2>

<h3 id="the-basic-structure">The basic structure</h3>
<p>We’ll put a recursive subroutine called <code>changer</code> instead of the nested for loops.  This function would go where the for loops were in the iterative solution and be called at the end of <code>makeChange</code>:</p>

<div class="highlight"><pre><code class="javascript"><span class="kd">var</span> <span class="nx">makeChange</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">total</span><span class="p">)</span> <span class="p">{</span>

  <span class="kd">var</span> <span class="nx">coins</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">50</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">200</span><span class="p">];</span>
  <span class="kd">var</span> <span class="nx">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
 
  <span class="kd">var</span> <span class="nx">changer</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// our recursive function</span>
  <span class="p">};</span>

  <span class="nx">changer</span><span class="p">();</span>
  <span class="k">return</span> <span class="nx">count</span><span class="p">;</span>
<span class="p">};</span>

<span class="nx">makeChange</span><span class="p">(</span><span class="mi">200</span><span class="p">);</span>
</code></pre></div>

<h3 id="arguments">Arguments</h3>
<p>There are two things that we need to keep track of with each call of our recursive function.  We’ll want to make these arguments of the recursive function.  </p>

<p>First, we need to know which type of coin we’re adding to our pile.  In the iterative version, we keep track of this in the decrement at every level of for loops.  Here, we’ll use <code>index</code> to know which coin in the <code>coins</code> array we’re working with.  Second, as we add coins to our pile, we need to keep track of the value still needed to reach the <code>total</code>.  In the iterative version, we do this by initializing the variable in each nested loop to the value of the previous loop (as in var b = a, var c = b, etc.)  In this recursive version, we save this information in a variable called <code>valueLeft</code> and we’ll initially set it to <code>total</code>.  </p>

<div class="highlight"><pre><code class="javascript">  <span class="kd">var</span> <span class="nx">changer</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">index</span><span class="p">,</span> <span class="nx">valueLeft</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// our recursive function</span>
  <span class="p">}</span>
  <span class="nx">changer</span><span class="p">(</span><span class="nx">coins</span><span class="p">.</span><span class="nx">length</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nx">total</span><span class="p">);</span>
</code></pre></div>

<h3 id="inside-the-recursive-function">Inside the Recursive Function</h3>

<p>We’ve already decided that we’ll start with the highest-valued coin and work backwards through the <code>coins</code> array.  Let’s access this coin with the index and save it to <code>currentCoin</code>.</p>

<div class="highlight"><pre><code class="javascript">    <span class="kd">var</span> <span class="nx">currentCoin</span> <span class="o">=</span> <span class="nx">coins</span><span class="p">[</span><span class="nx">index</span><span class="p">];</span>
</code></pre></div>

<p>Now that we have <code>coinsLeft</code>, <code>valueLeft</code>, and <code>currentCoin</code>, we can start creating ‘piles’ of coins that add up to <code>total</code>.  We can do this by calling the recursive function with a copy of <code>coinsLeft</code> and <code>valueLeft</code>, moving our way deep into the <code>coinsLeft</code> array just as we moved deep into the nested for loops. </p>

<div class="highlight"><pre><code class="javascript">    <span class="k">while</span><span class="p">(</span><span class="nx">valueLeft</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// call the function with the new index and the total value still needed</span>
      <span class="c1">// this goes maximally deep (to the 1p pieces) before doing anything else</span>
      <span class="nx">changer</span><span class="p">(</span><span class="nx">index</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nx">valueLeft</span><span class="p">);</span>
      <span class="c1">// reduce the total value still needed by the value of the coin popped</span>
      <span class="nx">valueLeft</span> <span class="o">-=</span> <span class="nx">currentCoin</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div>

<p>But when do we increment our counter and capture the number of possible ways to reach the total?  This is done when the index of <code>coins</code> reaches 0 (we’ve tried putting all the types of coins in the pile) and we’re not going over the total (we can make up the rest of the <code>value</code> needed with the <code>currentCoin</code> without a remainder). Once we reach this point, we want to return out of the loop.</p>

<div class="highlight"><pre><code class="javascript">    <span class="k">if</span> <span class="p">(</span><span class="nx">index</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">value</span> <span class="o">%</span> <span class="nx">currentCoin</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">count</span><span class="o">++</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div>

<p>Putting this all together, we get the final code like below:</p>

<div class="highlight"><pre><code class="javascript"><span class="kd">var</span> <span class="nx">makeChange</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">total</span><span class="p">){</span>
  <span class="kd">var</span> <span class="nx">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">coins</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">200</span><span class="p">];</span>

  <span class="kd">var</span> <span class="nx">changer</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">index</span><span class="p">,</span> <span class="nx">value</span><span class="p">){</span>

    <span class="kd">var</span> <span class="nx">currentCoin</span> <span class="o">=</span> <span class="nx">coins</span><span class="p">[</span><span class="nx">index</span><span class="p">];</span>

    <span class="k">if</span><span class="p">(</span> <span class="nx">index</span> <span class="o">===</span> <span class="mi">0</span><span class="p">){</span>
      <span class="k">if</span><span class="p">(</span> <span class="nx">value</span> <span class="o">%</span> <span class="nx">currentCoin</span> <span class="o">===</span> <span class="mi">0</span><span class="p">){</span>
        <span class="nx">count</span><span class="o">++</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">while</span><span class="p">(</span> <span class="nx">value</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">){</span>
      <span class="nx">changer</span><span class="p">(</span><span class="nx">index</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
      <span class="nx">value</span> <span class="o">-=</span> <span class="nx">currentCoin</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="nx">changer</span><span class="p">(</span><span class="nx">coins</span><span class="p">.</span><span class="nx">length</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nx">total</span><span class="p">);</span>
  <span class="k">return</span> <span class="nx">count</span><span class="p">;</span>
<span class="p">};</span>

<span class="nx">makeChange</span><span class="p">(</span><span class="mi">200</span><span class="p">);</span>
</code></pre></div>

 -->
    <h2 id="the-problem">The Problem</h2>
<p>How many possible ways can you make change for 2£ given the following English coins:
1p, 2p, 5p, 10p, 20p, 50p, 1£ (100p), 2£ (200p)?</p>


    <div "read-more"><a href="/coin-sums/">Read More</a></div>
  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    <div class="entry-meta"><span class="entry-date date published updated"><time datetime="2014-01-16T00:00:00-08:00"><a href="/from-iterative-to-recursive/">January 16, 2014</a></time></span><span class="author vcard"><span class="fn"><a href="/about/" title="About Jeanette Pettibone">Jeanette Pettibone</a></span></span></div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="/from-iterative-to-recursive/" rel="bookmark" title="From Iterative to Recursive" itemprop="url">From Iterative to Recursive</a></h1>
    
  </header>
  <div class="entry-content">
    <!-- <h2 id="thinking-recursively">Thinking Recursively</h2>
<p>Thinking recursively doesn’t come naturally to me so I am fascinated by the fact that iterative functions can be expressed recursively.  In this post I offer a step-by-step demonstration of how to turn the iterative <a href="http://jgpettibone.github.io/rock-paper-scissors/">Rock Paper Scissors</a> solution into the recursive one. </p>

<h3 id="iteration-or-recursion">Iteration or Recursion?</h3>
<p>Besides just the pleasure of getting a better understanding of recursion, why would I want to turn an iterative function into a recursive one?  </p>

<ul>
  <li>
    <p>Flexibility: We use recursion when we have a complex task that can be broken up into many similar subtasks.  In the <a href="http://jgpettibone.github.io/rock-paper-scissors/">Rock Paper Scissors</a> example, if we want the user to determine how many rounds of play will occur then we don’t know in advance the number of iterations we’ll need.  Recursion allows the flexibility to continue working on these subtasks for any number of iterations.  We just need to know when to stop / what the exit strategy is.</p>
  </li>
  <li>
    <p>Mutation: Recursion allows for iteration without mutation.  Mutating internal variables is usually harmless, but sometimes data mutation can cause unintended side effects.  (For more information, check out the wikipedia article on <a href="http://en.wikipedia.org/wiki/Pure_function">Pure functions</a>.)  In the <a href="http://jgpettibone.github.io/rock-paper-scissors/">Rock Paper Scissors</a> example, we use .concat to create a new array with the additional element without modifying or destroying the original array.   </p>
  </li>
  <li>
    <p>Expressiveness and elegance: Recursive functions tend to be beautifully succint and it can be incredibly satisfying to write such elegant code.  This isn’t always the case, however.  Some algorithms naturally lend themselves better to one approach or another.  For more complex systems, we often spend more time testing and debugging code than we do writing it so it’s important to think of the readability of your code as well as the ease of maintenance.</p>
  </li>
</ul>

<p>But there are alos some reasons why I might not want a recursive solution.  A recursive function calls itself to complete each of its subtasks.  Each of these function calls gets put on the function call stack until that function is completed. </p>

<ul>
  <li>
    <p>Performance: In general, recursion tends to run more slowly than iteration because there is the overhead cost of multiple function calls. </p>
  </li>
  <li>
    <p>Stack space: Each of these function calls gets added to the stack and stack space is limited.  This can eventually cause a stack overflow.</p>
  </li>
</ul>

<p>Of course, there are ways to minimize performance and stack space issues, but that’s not the focus of this post.</p>

<h2 id="step-by-step-from-the-iterative-solution">Step-By-Step from the Iterative Solution:</h2>

<p>Let’s start with the case that there are three rounds of play and therefore three nested for loops:</p>

<div class="highlight"><pre><code class="javascript"><span class="kd">var</span> <span class="nx">rockPaperScissors</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">outcomes</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="kd">var</span> <span class="nx">plays</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;rock&#39;</span><span class="p">,</span> <span class="s1">&#39;paper&#39;</span><span class="p">,</span> <span class="s1">&#39;scissors&#39;</span><span class="p">];</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">k</span> <span class="o">&lt;</span> <span class="nx">plays</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">plays</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">plays</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">outcomes</span><span class="p">.</span><span class="nx">push</span><span class="p">([</span><span class="nx">plays</span><span class="p">[</span><span class="nx">k</span><span class="p">],</span> <span class="nx">plays</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">plays</span><span class="p">[</span><span class="nx">i</span><span class="p">]]);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">outcomes</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<h3 id="step-one-start-at-the-inner-most-for-loop-and-create-a-new-function">Step One: Start at the Inner-Most For-Loop and Create a New Function</h3>
<p>In this example, we’ll want to refactor the line of code that pushes the possible outcomes (<code>[plays[k], plays[j], plays[i]]</code>) into the <code>outcomes</code> array as a separate and stand-alone function.</p>

<p>Let’s call this new function <code>combos_0</code> (we’ll be making a number of these <code>combos</code> functions).  Since <code>combos_0</code> is going to push an array into <code>outcomes</code>, <code>combos_0</code> needs to take an array as an argument.  Let’s call this <code>playedSoFar</code> since it will collect each of three plays in the three rounds.</p>

<div class="highlight"><pre><code class="javascript"><span class="kd">var</span> <span class="nx">combos_0</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">playedSoFar</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">outcomes</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">playedSoFar</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div>

<p>This function above will be invoked when we’re done with the recursion.</p>

<h3 id="step-two-go-loop-by-loop-and-create-new-functions">Step Two: Go Loop By Loop and Create New Functions</h3>
<p>We’ll start at the deepest of these loops and then work our way up.  This gives us three different functions, one for each of the nested for loops.  At each stage, we concatenate the play at each of the indices of the <code>plays</code> array into the <code>playedSoFar</code> array.       </p>

<div class="highlight"><pre><code class="javascript"><span class="kd">var</span> <span class="nx">combos_1</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">playedSoFar</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">plays</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">playedSoFar</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">plays</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">combos_2</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">playedSoFar</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">plays</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">playedSoFar</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">plays</span><span class="p">[</span><span class="nx">j</span><span class="p">]);</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">combos_3</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">playedSoFar</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">k</span> <span class="o">&lt;</span> <span class="nx">plays</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">playedSoFar</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">plays</span><span class="p">[</span><span class="nx">k</span><span class="p">]);</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>

<p>It’s clear from the three functions above that there is a pattern here that is particularly good for recursion - the work can be divided into smaller subtasks that all do the same thing.  We can combine the three functions <code>combos_1</code>, <code>combos_2</code>, and <code>combos_3</code> into one function that is invoked when with the recursive call.  </p>

<h3 id="step-three-putting-the-recursive-subroutine-together">Step Three: Putting the Recursive Subroutine Together</h3>
<p>Now we need to figure out how the parts from Step One and Step Two fit together in a recursive subroutine.  We’ll call this subroutine <code>getOutcomes</code>.</p>

<h4 id="combining-the-combosn-functions">Combining the <code>combos_n</code> functions</h4>
<p>We’ll use the for loop found in the <code>combos</code> functions to iterative over the plays list but now we’ll be completing the subtasks by calling the recursive subroutine. </p>

<div class="highlight"><pre><code class="javascript"><span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">plays</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
  <span class="nx">getOutcomes</span><span class="p">(</span>                       <span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>But what is the argument that goes into this subroutine?  How about the following?  </p>

<div class="highlight"><pre><code class="javascript"><span class="nx">playedSoFar</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">plays</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
</code></pre></div>

<p>We actually want to make calls to the recursive function without mutating the original data.  We shouldn’t use <code>push</code> to modify <code>playedSoFar</code> because it will mutate the array.  Instead, we need to use <code>concat</code> which creates a new array and is therefore not destructive.  </p>

<p>An example:</p>

<ul>
  <li>
    <p>Imagine <code>playedSoFar</code> contains [‘rock’] </p>
  </li>
  <li>
    <p>We want to iterate through the for loop so that each iteration adds one more possible play onto <code>playedSoFar</code> so that we get <code>playedSoFar</code> ([‘rock’]) + ‘rock’ ([‘rock’, ‘rock’]), <code>playedSoFar</code> ([‘rock’]) + ‘paper’ ([‘rock’, ‘paper’]), and <code>playedSoFar</code> ([‘rock’]) + ‘scissors’ ([‘rock’, ‘scissors’]).  </p>
  </li>
  <li>
    <p>DON’T USE PUSH: If we push each of these plays into <code>playedSoFar</code>, we’ll get <code>playedSoFar</code> ([‘rock’]) + ‘rock’ ([‘rock’, ‘rock’]), <code>playedSoFar</code> ([‘rock’, ‘rock’]) + ‘paper’ ([‘rock’, ‘rock’, paper’]), and <code>playedSoFar</code> ([‘rock’, ‘rock’, paper’]) + ‘scissors’ ([‘rock’, ‘rock’, ‘paper’, ‘scissors’]). </p>
  </li>
  <li>
    <p>DO USE CONCAT: Instead of using destructive <code>push</code>, we can use <code>concat</code> which creates a new array without mutating the original.  The new array is passed as an argument into the recursive subroutine and the original is used to concat the next elements.  This gives us what we want - <code>playedSoFar</code> ([‘rock’]) + ‘rock’ ([‘rock’, ‘rock’]), <code>playedSoFar</code> ([‘rock’]) + ‘paper’ ([‘rock’, ‘paper’]), and <code>playedSoFar</code> ([‘rock’]) + ‘scissors’ ([‘rock’, ‘scissors’])</p>
  </li>
</ul>

<p>This gives us the following code:</p>

<div class="highlight"><pre><code class="javascript"><span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">plays</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
  <span class="nx">getOutcomes</span><span class="p">(</span><span class="nx">playedSoFar</span><span class="p">.</span><span class="nx">concat</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
<span class="p">}</span>
</code></pre></div>

<h4 id="exit-strategy---when-is-the-recursion-finished">Exit Strategy - When is the Recursion Finished?</h4>
<p>In this example, there are 3 rounds being played (represented by the three nested loops in the iterative function).  We’re done with the recursion when we go through all the rounds and there are no more rounds left to play.  If we have a variable called <code>roundsLeft</code> that stores this information, we’ll be done when <code>roundsLeft</code> is zero.  So <code>combos_0</code> turns into the following:</p>

<div class="highlight"><pre><code class="javascript"><span class="k">if</span> <span class="p">(</span><span class="nx">roundsLeft</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">outcomes</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">playedSoFar</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div>

<p>So <code>roundsLeft</code> will need to be an argument passed into the recursive subroutine <code>getOutcomes</code>.</p>

<h4 id="keeping-track-of-rounds-left">Keeping Track of Rounds Left</h4>
<p>We’ll need to include <code>roundsLeft</code> as an argument of the recursive function so we’ll modify the recurive call as such:</p>

<div class="highlight"><pre><code class="javascript"><span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">plays</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
  <span class="nx">getOutcomes</span><span class="p">(</span><span class="nx">playedSoFar</span><span class="p">.</span><span class="nx">concat</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">roundsLeft</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<h4 id="the-recursive-subroutine">The Recursive Subroutine</h4>

<div class="highlight"><pre><code class="javascript">  <span class="kd">var</span> <span class="nx">getOutcomes</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">playedSoFar</span><span class="p">,</span> <span class="nx">roundsLeft</span><span class="p">)</span> <span class="p">{</span>    
    <span class="k">if</span> <span class="p">(</span><span class="nx">roundsLeft</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">outcomes</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">playedSoFar</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">plays</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">getOutcomes</span><span class="p">(</span><span class="nx">playedSoFar</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">plays</span><span class="p">[</span><span class="nx">i</span><span class="p">]),</span> <span class="nx">roundsLeft</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">};</span>
</code></pre></div>

<h3 id="step-four-replacing-the-iterative-for-loops-with-the-recursive-subroutine">Step Four: Replacing the Iterative For Loops with the Recursive Subroutine</h3>
<p>After completing the steps above, we can put the recursive subroutine in where the nested for loops were in the iterative approach.  And there is one more thing we have to do - call the recursive function with the appropriate arguments.  In this case, <code>playedSoFar</code> starts as the empty array and <code>roundsLeft</code> starts as 3, the number of rounds of play specified in this example.</p>

<div class="highlight"><pre><code class="javascript"><span class="kd">var</span> <span class="nx">rockPaperScissors</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">outcomes</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="kd">var</span> <span class="nx">plays</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;rock&#39;</span><span class="p">,</span> <span class="s1">&#39;paper&#39;</span><span class="p">,</span> <span class="s1">&#39;scissors&#39;</span><span class="p">];</span>
  <span class="kd">var</span> <span class="nx">getOutcomes</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">playedSoFar</span><span class="p">,</span> <span class="nx">roundsLeft</span><span class="p">)</span> <span class="p">{</span>    
    <span class="k">if</span> <span class="p">(</span><span class="nx">roundsLeft</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">outcomes</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">playedSoFar</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">plays</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">getOutcomes</span><span class="p">(</span><span class="nx">playedSoFar</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">plays</span><span class="p">[</span><span class="nx">i</span><span class="p">]),</span> <span class="nx">roundsLeft</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">};</span>
  <span class="nx">getOutcomes</span><span class="p">([],</span> <span class="mi">3</span><span class="p">);</span>
  <span class="k">return</span> <span class="nx">outcomes</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<p>Note: It is now trivial to make this function work with any number of rounds, not just 3.  We can do this by allowing <code>rockPaperScissors</code> to take an argument called <code>rounds</code> that specifies the number of rounds of play.  See the code below for this alternative:</p>

<div class="highlight"><pre><code class="javascript"><span class="kd">var</span> <span class="nx">rockPaperScissors</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">rounds</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">rounds</span> <span class="o">=</span> <span class="nx">rounds</span> <span class="o">||</span> <span class="mi">3</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">outcomes</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="kd">var</span> <span class="nx">plays</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;rock&#39;</span><span class="p">,</span> <span class="s1">&#39;paper&#39;</span><span class="p">,</span> <span class="s1">&#39;scissors&#39;</span><span class="p">];</span>
  <span class="kd">var</span> <span class="nx">getOutcomes</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">playedSoFar</span><span class="p">,</span> <span class="nx">roundsLeft</span><span class="p">)</span> <span class="p">{</span>    
    <span class="k">if</span> <span class="p">(</span><span class="nx">roundsLeft</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">outcomes</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">playedSoFar</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">plays</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">getOutcomes</span><span class="p">(</span><span class="nx">playedSoFar</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">plays</span><span class="p">[</span><span class="nx">i</span><span class="p">]),</span> <span class="nx">roundsLeft</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">};</span>
  <span class="nx">getOutcomes</span><span class="p">([],</span> <span class="nx">rounds</span><span class="p">);</span>
  <span class="k">return</span> <span class="nx">outcomes</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

 -->
    <h2 id="thinking-recursively">Thinking Recursively</h2>
<p>Thinking recursively doesn’t come naturally to me so I am fascinated by the fact that iterative functions can be expressed recursively.  In this post I offer a step-by-step demonstration of how to turn the iterative <a href="http://jgpettibone.github.io/rock-paper-scissors/">Rock Paper Scissors</a> solution into the recursive one. </p>


    <div "read-more"><a href="/from-iterative-to-recursive/">Read More</a></div>
  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    <div class="entry-meta"><span class="entry-date date published updated"><time datetime="2014-01-15T00:00:00-08:00"><a href="/rock-paper-scissors/">January 15, 2014</a></time></span><span class="author vcard"><span class="fn"><a href="/about/" title="About Jeanette Pettibone">Jeanette Pettibone</a></span></span></div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="/rock-paper-scissors/" rel="bookmark" title="Rock Paper Scissors" itemprop="url">Rock Paper Scissors</a></h1>
    
  </header>
  <div class="entry-content">
    <!-- <h2 id="the-problem">The Problem</h2>
<p>Write a function that generates every sequence of throws a single player could throw over a three-round game of rock-paper-scissors.  For instance, one player might play ‘rock’ in every round so the outcome for this player would be [‘rock’, ‘rock’, ‘rock’].  Another player might choose a different play in each round so the outcome would be something like [‘paper’, ‘rock’, ‘scissors’].  </p>

<h2 id="understanding-the-problem">Understanding the Problem</h2>
<p>This is a combinatorics problem.  We already know that there will be 27 solutions to this problem: there are three possible plays in the first round, three possible plays in the second round, and three possible plays in the third round - 3 x 3 x 3 = 27.</p>

<p>The solution to this problem will be an array containing 27 arrays, each corresponding to one possible outcome.  For instance:</p>

<div class="highlight"><pre><code class="javascript"><span class="p">[</span>
  <span class="p">[</span><span class="s1">&#39;rock&#39;</span><span class="p">,</span> <span class="s1">&#39;rock&#39;</span><span class="p">,</span> <span class="s1">&#39;rock&#39;</span><span class="p">],</span>
  <span class="p">[</span><span class="s1">&#39;rock&#39;</span><span class="p">,</span> <span class="s1">&#39;rock&#39;</span><span class="p">,</span> <span class="s1">&#39;paper&#39;</span><span class="p">],</span>
  <span class="p">[</span><span class="s1">&#39;rock&#39;</span><span class="p">,</span> <span class="s1">&#39;rock&#39;</span><span class="p">,</span> <span class="s1">&#39;scissors&#39;</span><span class="p">],</span>
  <span class="p">[</span><span class="s1">&#39;rock&#39;</span><span class="p">,</span> <span class="s1">&#39;paper&#39;</span><span class="p">,</span> <span class="s1">&#39;rock&#39;</span><span class="p">],</span>
  <span class="p">[</span><span class="s1">&#39;rock&#39;</span><span class="p">,</span> <span class="s1">&#39;paper&#39;</span><span class="p">,</span> <span class="s1">&#39;paper&#39;</span><span class="p">],</span>
  <span class="p">...</span>
  <span class="p">[</span><span class="s1">&#39;scissors&#39;</span><span class="p">,</span> <span class="s1">&#39;scissors&#39;</span><span class="p">,</span> <span class="s1">&#39;rock&#39;</span><span class="p">],</span>
  <span class="p">[</span><span class="s1">&#39;scissors&#39;</span><span class="p">,</span> <span class="s1">&#39;scissors&#39;</span><span class="p">,</span> <span class="s1">&#39;paper&#39;</span><span class="p">],</span>
  <span class="p">[</span><span class="s1">&#39;scissors&#39;</span><span class="p">,</span> <span class="s1">&#39;scissors&#39;</span><span class="p">,</span> <span class="s1">&#39;scissors&#39;</span><span class="p">],</span>
<span class="p">]</span>
</code></pre></div>

<h2 id="the-code">The Code</h2>

<h3 id="input-and-output">Input and Output</h3>
<p>The three possible plays are stored in an array called <code>plays</code>.  The return matrix is stored in a variable called <code>outcomes</code>.</p>

<h2 id="an-iterative-approach">An Iterative Approach</h2>
<p>Since we know that there are exactly three rounds in the game, we can easily create a series of three nested for loops to find the answer to this problem.    </p>

<div class="highlight"><pre><code class="javascript"><span class="kd">var</span> <span class="nx">rockPaperScissors</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">outcomes</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="kd">var</span> <span class="nx">plays</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;rock&#39;</span><span class="p">,</span> <span class="s1">&#39;paper&#39;</span><span class="p">,</span> <span class="s1">&#39;scissors&#39;</span><span class="p">];</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">k</span> <span class="o">&lt;</span> <span class="nx">plays</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">plays</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">plays</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">outcomes</span><span class="p">.</span><span class="nx">push</span><span class="p">([</span><span class="nx">plays</span><span class="p">[</span><span class="nx">k</span><span class="p">],</span> <span class="nx">plays</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">plays</span><span class="p">[</span><span class="nx">i</span><span class="p">]]);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">outcomes</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<h2 id="what-if--">What if … ?</h2>
<p>What if we didn’t know how many rounds the players would play?  How could we modify this function to deal with any number of rounds?  It would be really difficult to create an iterative approach like this when the number of rounds is determined by user input.  A recursive approach would make this problem much easier.</p>

<h2 id="a-recursive-approach">A Recursive Approach</h2>
<p>For a step-by-step way of turning an iterative function into a recursive, check out the <a href="http://jgpettibone.github.io/from-iterative-to-recursive/">From Iterative to Recursive</a> post.</p>

<h3 id="the-basic-structure-of-recursion">The basic structure of recursion</h3>
<p>Because the number of rounds is now variable, this number will be the argument passed into the <code>rockPaperScissors</code> function.  Let’s call this parameter <code>rounds</code>.</p>

<p>We’ll put a recursive subroutine called <code>getOutcomes</code> instead the main <code>rockPaperScissors</code> function.  This function would go where the for loops were in the iterative solution:</p>

<div class="highlight"><pre><code class="javascript"><span class="kd">var</span> <span class="nx">rockPaperScissors</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">rounds</span><span class="p">)</span> <span class="p">{</span>

  <span class="kd">var</span> <span class="nx">outcomes</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="kd">var</span> <span class="nx">plays</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;rock&#39;</span><span class="p">,</span> <span class="s1">&#39;paper&#39;</span><span class="p">,</span> <span class="s1">&#39;scissors&#39;</span><span class="p">];</span>

  <span class="kd">var</span> <span class="nx">getOutcomes</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>    
    <span class="c1">// the recursive function</span>
  <span class="p">};</span>

  <span class="nx">getOutcomes</span><span class="p">();</span>
  <span class="k">return</span> <span class="nx">outcomes</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<h3 id="arguments">Arguments</h3>
<p>There are two things that we need to keep track of with each call of our recursive function so let’s make these arguments of the recursive function.  </p>

<p>First, we need to keep track of the plays that we have played so far.  This can be stored in a variable called <code>playedSoFar</code>.  We also need to keep track of the number of rounds left.  This can be stored in a variable called <code>roundsLeft</code>.  This recursive subroutine will be called with the empty array for <code>playedSoFar</code> and <code>rounds</code> for <code>roundsLeft</code>. </p>

<div class="highlight"><pre><code class="javascript">  <span class="kd">var</span> <span class="nx">getOutcomes</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">playedSoFar</span><span class="p">,</span> <span class="nx">roundsLeft</span><span class="p">)</span> <span class="p">{</span>    
    <span class="c1">// the recursive function</span>
  <span class="p">};</span>
  <span class="nx">getOutcomes</span><span class="p">([],</span><span class="nx">rounds</span><span class="p">);</span>
</code></pre></div>

<h3 id="inside-the-recursive-function">Inside the Recursive Function</h3>

<h4 id="exit-strategy">Exit Strategy</h4>
<p>We’ve reached the end of the game when there are no more rounds left.  So once <code>roundsLeft</code> is zero, we’re ready to push the possible plays that we’ve gathered into the <code>outcomes</code> array that the function will return.</p>

<div class="highlight"><pre><code class="javascript">    <span class="k">if</span> <span class="p">(</span><span class="nx">roundsLeft</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">outcomes</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">playedSoFar</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div>

<h4 id="recursing">Recursing</h4>
<p>If there are still rounds left, we want to keep gathering plays.  We’ll need to iterate over the <code>plays</code> array and call the recursive subroutine <code>getOutcomes</code> for each of these possible plays.</p>

<div class="highlight"><pre><code class="javascript">    <span class="k">else</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">plays</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">getOutcomes</span><span class="p">(</span><span class="nx">playedSoFar</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">plays</span><span class="p">[</span><span class="nx">i</span><span class="p">]),</span> <span class="nx">roundsLeft</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div>

<h3 id="putting-it-all-together">Putting it all together</h3>
<p>Now that we know the logic that happens inside of the recursive subroutine, we can put the whole <code>rockPaperScissors</code> function together.  Note that it accepts an argument called <code>rounds</code>.  If the argument is undefined, we’ll default that value to 3.</p>

<div class="highlight"><pre><code class="javascript"><span class="kd">var</span> <span class="nx">rockPaperScissors</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">rounds</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">rounds</span> <span class="o">=</span> <span class="nx">rounds</span> <span class="o">||</span> <span class="mi">3</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">outcomes</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="kd">var</span> <span class="nx">plays</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;rock&#39;</span><span class="p">,</span> <span class="s1">&#39;paper&#39;</span><span class="p">,</span> <span class="s1">&#39;scissors&#39;</span><span class="p">];</span>
  <span class="kd">var</span> <span class="nx">getOutcomes</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">playedSoFar</span><span class="p">,</span> <span class="nx">roundsLeft</span><span class="p">)</span> <span class="p">{</span>    
    <span class="k">if</span> <span class="p">(</span><span class="nx">roundsLeft</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">outcomes</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">playedSoFar</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">plays</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">getOutcomes</span><span class="p">(</span><span class="nx">playedSoFar</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">plays</span><span class="p">[</span><span class="nx">i</span><span class="p">]),</span> <span class="nx">roundsLeft</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">};</span>
  <span class="nx">getOutcomes</span><span class="p">([],</span> <span class="nx">rounds</span><span class="p">);</span>
  <span class="k">return</span> <span class="nx">outcomes</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

 -->
    <h2 id="the-problem">The Problem</h2>
<p>Write a function that generates every sequence of throws a single player could throw over a three-round game of rock-paper-scissors.  For instance, one player might play ‘rock’ in every round so the outcome for this player would be [‘rock’, ‘rock’, ‘rock’].  Another player might choose a different play in each round so the outcome would be something like [‘paper’, ‘rock’, ‘scissors’].  </p>


    <div "read-more"><a href="/rock-paper-scissors/">Read More</a></div>
  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    <div class="entry-meta"><span class="entry-date date published updated"><time datetime="2014-01-08T00:00:00-08:00"><a href="/shuffle/">January 08, 2014</a></time></span><span class="author vcard"><span class="fn"><a href="/about/" title="About Jeanette Pettibone">Jeanette Pettibone</a></span></span></div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="/shuffle/" rel="bookmark" title="Shuffle" itemprop="url">Shuffle</a></h1>
    
  </header>
  <div class="entry-content">
    <!-- <h2 id="the-problem">The Problem</h2>
<p>Recreate the functionality of the <a href="http://underscorejs.org/">Underscore.js</a> _.shuffle function.</p>

<h2 id="understanding-the-problem">Understanding the Problem</h2>
<p><a href="http://en.wikipedia.org/wiki/Shuffling#Shuffling%5Falgorithms">Shuffling algorithms</a> can be considered the opposite of sorting algorithms.  The goal of the shuffle function is to randomize the content of an array (for this exercise, I limited my versions of the shuffle function to accept only arrays) so that there is no particular order based on any criteria whatsoever.  </p>

<h2 id="various-versions">Various Versions</h2>

<h3 id="fisher-yates-shuffle">Fisher-Yates Shuffle</h3>
<p>A simple Google search showed me that the most popular shuffling algorithm is <a href="http://en.wikipedia.org/wiki/Fisher-Yates_shuffle">Fisher-Yates Shuffle</a>.  This algorithm starts by looking at the whole range of indices in the array and then swapping the value in the last index with the value in a random index within the range of indices.  On the next iteration, the range of indices shrinks by 1 since the last element in the array has already been placed with the shuffle.  The array is effectively being divided into an already-shuffled section and a to-be-shuffled one.  This continues until the whole array has been shuffled.  And since every permutation is equally likely, this algorithm is unbiased.  </p>

<p>Here’s a table view of what is happening for the array [0,1,2,3].</p>

<table rules="groups">
  <thead>
    <tr>
      <th style="text-align: left">Range -</th>
      <th style="text-align: center">- Random Index -</th>
      <th style="text-align: center">- Unshuffled Section -</th>
      <th style="text-align: right">- Shuffled Section</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center">0 1 2 3</td>
      <td style="text-align: right"> </td>
    </tr>
    <tr>
      <td style="text-align: left">0-3</td>
      <td style="text-align: center">2</td>
      <td style="text-align: center">0 1 3</td>
      <td style="text-align: right">2</td>
    </tr>
    <tr>
      <td style="text-align: left">0-2</td>
      <td style="text-align: center">3</td>
      <td style="text-align: center">0 1</td>
      <td style="text-align: right">3 2</td>
    </tr>
    <tr>
      <td style="text-align: left">0-1</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">1</td>
      <td style="text-align: right">0 3 2</td>
    </tr>
    <tr>
      <td style="text-align: left">0</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center"> </td>
      <td style="text-align: right">1 0 3 2</td>
    </tr>
  </tbody>
</table>

<p>Below is my implementation of _.shuffle.</p>

<div class="highlight"><pre><code class="javascript"><span class="nx">_</span><span class="p">.</span><span class="nx">shuffle</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">array</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">newArr</span> <span class="o">=</span> <span class="nx">array</span><span class="p">.</span><span class="nx">slice</span><span class="p">();</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span><span class="o">=</span><span class="nx">array</span><span class="p">.</span><span class="nx">length</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="nx">i</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">rand</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">round</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">()</span> <span class="o">*</span> <span class="nx">i</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">temp</span> <span class="o">=</span> <span class="nx">newArr</span><span class="p">[</span><span class="nx">rand</span><span class="p">];</span>
    <span class="nx">newArr</span><span class="p">[</span><span class="nx">rand</span><span class="p">]</span> <span class="o">=</span> <span class="nx">newArr</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
    <span class="nx">newArr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">temp</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">newArr</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<h3 id="using-sort">Using Sort</h3>
<p>There is also a clever way to make _.shuffle using a customized sort() method. </p>

<div class="highlight"><pre><code class="javascript"><span class="nx">_</span><span class="p">.</span><span class="nx">shuffle</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">array</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">array</span><span class="p">.</span><span class="nx">slice</span><span class="p">().</span><span class="nx">sort</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">()</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">;</span> <span class="p">});</span>
<span class="p">};</span>
</code></pre></div>

<p>However, this isn’t necessarily completely random.  The elements will be biased towards their original positions in the array.</p>

<p>For more information about these two methods of shuffling, check out <a href="http://stackoverflow.com/questions/962802/is-it-correct-to-use-javascript-array-sort-method-for-shuffling">this Stack Overflow post</a>.  I especially appreciated Christoph’s discussion and his implementation.</p>

<h3 id="christophs-implementation-on-stack-overflow">Christoph’s implementation on Stack Overflow</h3>

<div class="highlight"><pre><code class="javascript"><span class="kd">function</span> <span class="nx">shuffle</span><span class="p">(</span><span class="nx">array</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">tmp</span><span class="p">,</span> <span class="nx">current</span><span class="p">,</span> <span class="nx">top</span> <span class="o">=</span> <span class="nx">array</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">top</span><span class="p">)</span> <span class="k">while</span><span class="p">(</span><span class="o">--</span><span class="nx">top</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">current</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="nx">top</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
    <span class="nx">tmp</span> <span class="o">=</span> <span class="nx">array</span><span class="p">[</span><span class="nx">current</span><span class="p">];</span>
    <span class="nx">array</span><span class="p">[</span><span class="nx">current</span><span class="p">]</span> <span class="o">=</span> <span class="nx">array</span><span class="p">[</span><span class="nx">top</span><span class="p">];</span>
    <span class="nx">array</span><span class="p">[</span><span class="nx">top</span><span class="p">]</span> <span class="o">=</span> <span class="nx">tmp</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">array</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="the-underscorejs-sourcehttpunderscorejsorgdocsunderscorehtml">The <a href="http://underscorejs.org/docs/underscore.html">Underscore.js Source</a></h3>
<p>The original underscore shuffle function takes any sort of collection, not just arrays.  </p>

<div class="highlight"><pre><code class="javascript"><span class="nx">_</span><span class="p">.</span><span class="nx">shuffle</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">rand</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">shuffled</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="nx">each</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">rand</span> <span class="o">=</span> <span class="nx">_</span><span class="p">.</span><span class="nx">random</span><span class="p">(</span><span class="nx">index</span><span class="o">++</span><span class="p">);</span>
    <span class="nx">shuffled</span><span class="p">[</span><span class="nx">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">shuffled</span><span class="p">[</span><span class="nx">rand</span><span class="p">];</span>
    <span class="nx">shuffled</span><span class="p">[</span><span class="nx">rand</span><span class="p">]</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
  <span class="p">});</span>
  <span class="k">return</span> <span class="nx">shuffled</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<p>And here’s a mixin to extend Underscore’s shuffle to use Fisher-Yates that I found <a href="https://github.com/ryantenney/underscore/commit/4890699d922cc9924ea28dd9ed21c1fefe33e4de#commitcomment-528646">here</a>.</p>

<div class="highlight"><pre><code class="javascript"><span class="nx">_</span><span class="p">.</span><span class="nx">mixin</span><span class="p">({</span>
  <span class="nx">shuffle</span> <span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">shuffled</span> <span class="o">=</span> <span class="p">[],</span> <span class="nx">rand</span><span class="p">;</span>
    <span class="nx">_</span><span class="p">.</span><span class="nx">each</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">value</span><span class="p">,</span> <span class="nx">index</span><span class="p">,</span> <span class="nx">list</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">shuffled</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">rand</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="nx">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
        <span class="nx">shuffled</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span> <span class="o">=</span> <span class="nx">shuffled</span><span class="p">[</span><span class="nx">rand</span><span class="p">];</span>
        <span class="nx">shuffled</span><span class="p">[</span><span class="nx">rand</span><span class="p">]</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">});</span>
    <span class="k">return</span> <span class="nx">shuffled</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">});</span>
</code></pre></div>

 -->
    <h2 id="the-problem">The Problem</h2>
<p>Recreate the functionality of the <a href="http://underscorejs.org/">Underscore.js</a> _.shuffle function.</p>


    <div "read-more"><a href="/shuffle/">Read More</a></div>
  </div><!-- /.entry-content -->
</article><!-- /.hentry -->


<div class="pagination">
  
    
      <a href="/page2" class="btn">Previous</a>
    
  
  <ul class="inline-list">
    <li>
      
        <a href="">1</a>
      
    </li>
    
      <li>
        
          <a href="/page2">2</a>
        
      </li>
    
      <li>
        
          <span class="current-page">3</span>
        
      </li>
    
  </ul>
  
    Next
  
</div><!-- /.pagination -->

</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2020 Jeanette Pettibone. Powered by <a href="http://jekyllrb.com">Jekyll</a> using the <a href="http://mademistakes.com/hpstr/">HPSTR Theme</a>.</span><br><span>         <a href="http://github.com/jgpettibone"><i class="icon-github"></i>  </a>  <a href="http://linkedin.com/in/jeanettepettibone"><i class="icon-linkedin"></i>  </a> <a href="http://twitter.com/jgpettibone"><i class="icon-twitter"></i>  </span>

  </footer>
</div><!-- /.footer-wrapper -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="/assets/js/scripts.min.js"></script>

          

</body>
</html>
