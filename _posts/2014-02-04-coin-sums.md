---
layout: post
title: Coin Sums
description: 
modified: 2014-02-04
tags: [toy problems, algorithms]
image:
  feature: great-britain-coins-money.jpg
comments: true
share: true
---

## The Problem
How many possible ways can you make change for 2£ given the following English coins:
1p, 2p, 5p, 10p, 20p, 50p, 1£ (100p), 2£ (200p)

One example output would be:
5*1p, 5*2p, 1*5p, 1*10p, 1*20p, 1*50p, 1*1£

## Understanding the Problem 
This problem deals with the possible permutations of coins that equal 2£.  However, it is not a pure combinatorics problem like Rock Paper Scissors because we do not want duplicates (1*1p,1*2p is the same as 1*2p,1*1p and therefore we should only count one of these combinations.)  Knowing this helps to reduce the problem.  What does the problem look like?

Let's start off by looking at a smaller version of this problem.  Imagine that we have only 3 different types of coins - 1p, 5p, and 10p - and we're trying to make 'piles' of coins that sum up to 20p.  What are the possible coin combinations that we can make?

Number of coins of each type used:

|   10p - | - 5p  - | - 1p    |
|:--------|:-------:|--------:|
|    0    |    0    |    20   |
|    0    |    1    |    15   |
|    0    |    2    |    10   |
|    0    |    3    |     5   |
|    0    |    4    |     0   |
|    1    |    0    |    10   |
|    1    |    1    |     5   |
|    1    |    2    |     0   |
|    2    |    0    |     0   |
{: rules="groups"}

There is a pattern here.  Looking at the first row of this table, we might think of this problem as starting by looking the largest-valued coin (10p) with 20p value needed to reach the total and adding none of this type of coin, and then looking at the next-largest-valued coin (5p) with still 20p value needed and adding none of this type of coin, and then finally getting to the 1p coin and iterating through to add 20 * 1p coins to reach the total of 20p.  Now look at the second row of the table.  In terms of Javascript, this looks like it could be represented by a series of nested for loops.    

## Javascript
Let's translate this problem into Javascript and write a function called `makeChange`.

### Input and Output
Let's make the argument of the function a variable called `total`.  Since our goal is for the coins to sum up to 2£ (or 200p), we'll call this for the first time with 200.

The return value should be the number of possible ways to make change for the total.  The return variable will be a counter initialized to 0.

### To Iterate or to Recurse?
An iterative approach requires that we hard-code each of the type of coins in their own for loop.  An iterative solution might look something like the following:

{% highlight javascript %}
var makeChange = function(total) {

  var coins = [1,2,5,10,20,50,100,200];
  var count = 0;

  for (var a = total; a >= 0; a -= coins[coins.length-1]) {
    for (var b = a; b >= 0; b -= coins[coins.length-2]) {
      for (var c = b; c >= 0; c -= coins[coins.length-3]) {
        for (var d = c; d >= 0; d -= coins[coins.length-4]) {
          for (var e = d; e >= 0; e -= coins[coins.length-5]) {
            for (var f = e; f >= 0; f -= coins[coins.length-6]) {
              for (var g = f; g >= 0; g -= coins[coins.length-7]) {
                count++;
              }
            }
          }
        }
      }
    }
  }
  return count;
};

makeChange(200);
{% endhighlight %}

We see that this problem can easily be divided into a series of similar subproblems - get all the combinations of coins with just 1p coins, all the combinations with 1p and 2p coins, all the combinations with 1p, 2p, and 5p coins, etc.  A problem like this is perfect for a recursive function.

## The Recursive Function

### The basic structure 
We'll put a recursive subroutine called `changer` instead of the nested for loops.  So the basic structure looks something like this:

{% highlight javascript %}
var makeChange = function(total) {

  var coins = [1,2,5,10,20,50,100,200];
  var count = 0;
 
  var changer = function() {
    // our recursive function
  };

  changer();
  return count;

};

makeChange(200);
{% endhighlight %}

### Arguments 
There are two things that we need to keep track of with each call of our recursive function.  We'll want to make these arguments of the recursive function.  

First, we need to know which type of coin we're adding to our pile.  In the iterative version, we keep track of this in the decrement at every level of for loops.  Second, as we add coins to our pile, we need to keep track of the value still needed to reach the `total`.  In the iterative version, we do this by initializing the variable in each nested loop to the value of the previous loop (as in var b = a, var c = b, etc.)  In this recursive version, we save this information in a variable called `valueLeft` and we'll initially set it to `total`.  

{% highlight javascript %}
  var changer = function(index, valueLeft) {
    // our recursive function
  }
  changer(coins.length-1, total);
{% endhighlight %}

### Inside the Recursive Function

We've already decided that we'll start with the highest-valued coin.  Let's save the highest-valued coin to a variable called `currentCoin`.

{% highlight javascript %}
    var currentCoin = coins[index];
{% endhighlight %}

And we know we want to start counting 

Now that we have `coinsLeft`, `valueLeft`, and `currentCoin`, we can start creating 'piles' of coins that add up to `total`.  We can do this by calling the recursive function with a copy of `coinsLeft` and `valueLeft`, moving our way deep into the `coinsLeft` array just as we moved deep into the nested for loops. 

{% highlight javascript %}
    while(valueLeft >= 0) {
      // call the function with the new index and the total value still needed
      // this goes maximally deep (to the 1p pieces) before doing anything else
      changer(index-1, valueLeft);
      // reduce the total value still needed by the value of the coin popped
      valueLeft -= currentCoin;
    }
{% endhighlight %}

But when do we count the ways possible?  This is done when the index reaches 0 and we're looking at a denomination other than 1p.  Once we reach this point, we want to return out of the loop.

{% highlight javascript %}
    if (index === 0) {
      if (value % currentCoin === 0) {
        count++;
      }
      return;
    }
{% endhighlight %}

Putting this all together, we get the following code:

{% highlight javascript %}
var makeChange = function(total){
  var count = 0;
  var coins = [1, 2, 5, 10, 20, 50, 100, 200];

  var changer = function(index, value){

    // we grab the value at the index (moving from the last index
    // backwards through the array)
    var currentCoin = coins[index];

    // exit strategy - when the index gets to 0 instead of when we have no 
    // more coins in the coinsLeft array
    if( index === 0){

      // modulus check - support a lowest denomination other than 1
      if( value % currentCoin === 0){
        count++;
      }
      return;
    }

    while( value >= 0 ){
      changer(index-1, value);
      value -= currentCoin;
    }
  }
  changer(coins.length-1, total);

  return count;
};

makeChange(200);
{% endhighlight %}


{% highlight javascript %}
{% endhighlight %}


