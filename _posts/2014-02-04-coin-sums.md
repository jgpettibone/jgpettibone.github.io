---
layout: post
title: Coin Sums
description: 
modified: 2014-02-04
tags: [toy problems, algorithms]
image:
  feature: great-britain-coins-money.jpg
comments: true
share: true
---

## The Problem
How many possible ways can you make change for 2£ given the following English coins:
1p, 2p, 5p, 10p, 20p, 50p, 1£ (100p), 2£ (200p)

One example output would be:
5 1p pieces, 5 2p pieces, 1 5p piece, 1 10p piece, 1 20p piece, 1 50p piece, 1 1£ piece

## Understanding the Problem 
This problem deals with the possible permutations of coins that equal 2£.  However, it is not a pure combinatorics problem like Rock Paper Scissors because we do not want duplicates (1p,2p is the same as 2p,1p and therefore we should only count one of these combinations.)  Knowing this helps to reduce the problem.  But in what way?  What does the problem look like?

Let's start off by looking at a smaller version of this problem.  Imagine that we have only 3 different types of coins - 1p, 5p, and 10p - and we're trying to make 'piles' of coins that sum up to 20p.  What are the possible coin combinations that we can make?

Number of coins of each type used:
|   10p   |   5p    |   1p    |
|:--------|:-------:|--------:|
|    0    |    0    |    20   |
|    0    |    1    |    15   |
|    0    |    2    |    10   |
|    0    |    3    |     5   |
|    0    |    4    |     0   |
|    1    |    0    |    10   |
|    1    |    1    |     5   |
|    1    |    2    |     0   |
|    2    |    0    |     0   |
{: rules="groups"}

There is a pattern here.  The largest-valued coin (10p) is only used in 4 of the 9 possible combinations.  So we do not need to iterate through every single type of coin when we try to create these 'piles.'  We can start by iterating with the largest coin to get those 4 combinations, then iterate through the next-largest to get an additional 4 combinations, and then iterate through the smallest to get the last combinations.

### To Iterate or to Recurse?
Since we'll be dividing this problem into similar subproblems, I'll use recursion.  However, it's possible to turn recursive functions into iterative ones and vice versa.  

I find it easiest in terms of readability to create a recursive subroutine inside a main function.  The return variable is declared and returned within the main function and the subroutine is called within the the main function.

### What is the return variable?
The problem asks for the number of possible ways to make change for 2£.  So the return variable will be a counter initialized to 0.

### The basic structure 

{% highlight javascript %}
var makeChange = function(total) {

  var coins = [1,2,5,10,20,50,100,200];
  var count = 0;
 
  var changer = function() {
    // our recursive function
  };

  changer();
  return count;

};
{% endhighlight %}

